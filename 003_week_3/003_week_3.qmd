---
title: "Week 3"
format: html
---

```{python}
import pandas as pd
import numpy as np
from palmerpenguins import load_penguins_raw, load_penguins
penguins_raw_df = load_penguins_raw()
penguins_df = load_penguins()

```

### Selecting Rows and Columns

-   `.info()` Very, very helpful

```{python}

penguins_raw_df.info()
```

### Subsetting Columns (aka `select`-ing) with `[ ]`

-   FWIW, subsetting == indexing == selecting == extracting
-   Remember, pass multiple values as a single argument using a **list**, with values within `[ ]`
-   When supply a list of column names as argument, result is **DataFrame** NOT **Series**

```{python}
penguins_raw_df['Individual ID']
```

```{python}
penguins_raw_df[['Individual ID', 'Species', 'Island']]
```

```{python}
penguins_raw_df[['Species', 'Region', 'Stage']]
```

### `.rename()`

-   Use dictionary to rename DataFrame columns
    -   `{'Old name 1': 'New Name 1', 'Old name 2': 'New Name 2'}`
-   NB: You have to reassign it. It won't make the change permanent without reassigning the object...

```{python}
penguins_raw_df.rename(columns = {'studyName': 'Study Name'})
```

```{python}
penguins_raw_df.rename(columns = {'studyName': 'Study', 'Sample Number': 'Sample', 'Individual ID': 'ID'})
```

### Selecting Rows with `.loc[]`

-   Can use `.loc[]` to filter data sets using a Boolean array as an input

```{python}
penguins_raw_df.loc[penguins_raw_df['Island'] == 'Torgersen']
```

Use this syntax to select by **rows only.**

`<dataset>.loc[<row indices>]`

Use this syntax to select by **rows and columns.**

`<dataset>.loc[<row indices>, <column indicies>]`

**NB:** `.loc[]` is a special ATTRIBUTE of DataFrame class that uses `[ ]` instead of `( )`

### Row Indices

-   Row index starts at 0 and increases by 1 for each row
-   Row index values always shown on left of DataFrame

```{python}
penguins_raw_df.loc[0]
```

```{python}
penguins_raw_df.loc[1, 'Species']
```

Can use `.loc[]` to select \>1 value. Use lists of row indicies and column names

```{python}
penguins_raw_df.loc[[0, 1, 2, 3], ['Species', 'Region', 'Island']]
```

### `start:end`

-   If row indicies or columns in consecutive order can use `:` which will grab all entries from the `start` element **up to and and including** the `end` element

```{python}
penguins_raw_df.loc[0:3, 'Species':'Island']
```

```{python}
penguins_raw_df.loc[25:35]
```

### `:` as a shorthand for ALL ROWS or ALL COLUMNS

```{python}
penguins_raw_df.loc[:, ['Species', 'Comments']]
```

NB: if only selecting columns, use `[ ]` instead of `.loc[]`

```{python}
penguins_raw_df[['Species', 'Comments']]
```

### Non-default row indicies

-   Can use something else, other than 0, 1, 2, .... (that is, name, etc.)

But then you have to use the index name. **`.loc[]` expects a NAME**

`new_index.loc['Tor_Ad_3']`

### Selecting by position with `.iloc[]`

-   Similar to `slice()`
-   `.iloc[]` `i`ndex `loc`ation (computer-readable) vs. `.loc[]` which is human readable locations (labels)

```{python}
penguins_raw_df.iloc[0, 0]
```

### Modify, Add, Derive Variables from Data Using `[ ]` Notation

```{python}
penguins_size = (
  penguins_df[[
    'species', 'flipper_length_mm', 'body_mass_g'
    ]]
    .rename(
      columns = {'flipper_length_mm': 'flipper_length', 'body_mass_g': 'body_mass'})
  )
```

```{python}
penguins_size['body_mass'] / 1000
```

### Python, like R, is vectorized....

```{python}

penguins_size['body_mass_kg'] = penguins_size['body_mass'] / 1000

penguins_size
```

Can use `[ ]` to modify or assign a column

1.  Select **New** column with `[ ]` as if it always existed

```{python}

penguins_size['flipper_length_cm'] = penguins_size['flipper_length'] / 100
# penguins_size['flipper_length'] * 0.1
```

```{python}
penguins_size['body_mass'] = penguins_size['body_mass'] / 1000
penguins_size['flipper_length'] = penguins_size['flipper_length'] / 100
```

```{python}
penguins_size['flipper_length_mean'] = penguins_size['flipper_length'].mean()

penguins_size['flipper_length'] = penguins_size['flipper_length'] - penguins_size['flipper_length_mean']
```

### Functions to use with `[ ]`

Using `[ ]`to assign or modify a column should work with any vectorized function.

+-----------------------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------+----------------------------------------------+
|                                   | Purpose                                                                                                                                                             | Example Usage                                |
+===================================+=====================================================================================================================================================================+==============================================+
| ***Operators***                   |                                                                                                                                                                     |                                              |
+-----------------------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------+----------------------------------------------+
| `+ - * / ^`                       | Math operations                                                                                                                                                     | `penguin_size['flipper_length'] / 100`       |
+-----------------------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------+----------------------------------------------+
| `// %`                            | Integer division and remainder                                                                                                                                      | `penguin_size['body_mass'] // 100`           |
|                                   |                                                                                                                                                                     |                                              |
|                                   |                                                                                                                                                                     | `penguin_size['body_mass'] % 100`            |
+-----------------------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------+----------------------------------------------+
| `< <= > >= != ==`                 | Logical operators returning `True` or `False`                                                                                                                       | `penguin_size['body_mass'] >= 4000`          |
+-----------------------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------+----------------------------------------------+
| ***Numerical Functions***         |                                                                                                                                                                     |                                              |
+-----------------------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------+----------------------------------------------+
| `.round()`                        | Round to specified number of digits                                                                                                                                 | `(flipper_length / 100).round()`             |
+-----------------------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------+----------------------------------------------+
| `.abs()`                          | Absolute value                                                                                                                                                      | `penguin_size['flipper_length'].abs()`       |
+-----------------------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------+----------------------------------------------+
| `numpy.sqrt()`                    | Compute square root                                                                                                                                                 | `numpy.sqrt(penguin_size['flipper_length'])` |
+-----------------------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------+----------------------------------------------+
| `numpy.log()`                     | Compute logarithm with natural, base 2, or base 10                                                                                                                  | `numpy.log10(penguin_size['body_mass'])`     |
|                                   |                                                                                                                                                                     |                                              |
| `numpy.log2()`                    |                                                                                                                                                                     |                                              |
|                                   |                                                                                                                                                                     |                                              |
| `numpy.log10()`                   |                                                                                                                                                                     |                                              |
+-----------------------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------+----------------------------------------------+
| ***Ordered Observations***        |                                                                                                                                                                     |                                              |
+-----------------------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------+----------------------------------------------+
| `.shift()`                        | Find the *previous* value by shifting values down—`.shift(1)`, or *next* value by shifting values up—`.shift(-1)`, in a column                                      | `penguin_size['flipper_length'].shift(1)`    |
+-----------------------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------+----------------------------------------------+
| `.rank()`                         | Rank the values in the column. Choose how ties are handled with `method` argument. Recommend keeping default `na_action = "keep"`.                                  | `penguin_size['body_mass'].rank()`           |
+-----------------------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------+----------------------------------------------+
| ***Cumulative Summary Function*** |                                                                                                                                                                     |                                              |
+-----------------------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------+----------------------------------------------+
| `.cumsum() .cummin() .cummax()`   | Cumulatively aggregated summaries. Returns a vector where each item is the cumulative summary statistic (.`sum()`, `.min()`) up to that entry in the input vector\> | `penguin_size['body_mass'].cummin()`         |
+-----------------------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------+----------------------------------------------+

### Challenge 1

```{python}

penguins_size['rank'] = penguins_size['body_mass'].rank(method = 'first')
penguins_size
```

### Challenge 2

```{python}
penguins_size['body_mass_diff'] = penguins_size['body_mass'] - penguins_size['body_mass'].mean()
penguins_size['body_mass_diff'] = penguins_size['body_mass_diff'].abs()
penguins_size['body_mass_diff'] = penguins_size['body_mass_diff'].round(decimals = 2)
penguins_size
```

### Non-Vectorized Functions

Many functions outside the PyData (???) ecosystem are NOT vectorized.

### MUST Use `.apply()` for non-vectorized functions

The `.apply()` methond takes a function as input and will **apply** the function to each value in the **Series**

`column.apply(func)`

1. `column` is code to select column of data `penguin_size['body_mass']`
2. `.apply()` method will run function iteratively.
3. `func` is actual function to apply. JUST THE NAME ONLY. It does NOT need `()`


```{python}
penguins_size['body_mass'].apply(lambda x: x ** 2) ## Anonymous function! Much easier than R. 
penguins_size['body_mass'].apply(np.log10)
```


```{python}
type(penguins_size['body_mass'])
```

**`.apply` can run on DataFrame objects for each column!**

### ChainedAssignmentError


```{python}
penguins_size['flipper_length'][0] = 181
```

Need to `df.loc[row_indexer, 'col'] = values`

Do NOT use `[ ]` to select **ROWS**, you must use **`.loc[]`**

To replace values in entire column you can use `[]`

`<dataset>['column_name'] = <new_values>`

To work with specific rows use `.loc[]`

`<dataset>.loc[<row_index>, <'column_name'>] = <new_value>`

```{python}
penguins_size.loc[penguins_size['species'] == 'Adelie', 'species'] = "ADELIE"
penguins_size
```

### `copy_on_write` Option

`pd.set_option("mode.copy_on_write", True)`

Chained assignment won't work with this option


```{python}
penguins_size.loc[0, 'body_mass'] = 3850
penguins_size

```

### Arrange rows in Data 

Using `.sort_values()`


```{python}
penguins = load_penguins()
penguins
```


```{python}
penguins.sort_values('bill_length_mm')
```

`.sort_values()` is method of DataFrame class. Can only use on DataFrame.

Required arguement = `by`

`<dataset>.sort_values('<column>')`

OR

`<dataset>.sort_values(['<column1>', '<column2>', ...])`

By default, `.sort_values()` will sort in ascending order

It also returns a **modified copy of original DataFrame.** If you want to save you have to assign it.

```{python}
penguins.sort_values('island')
```

### Tie Breakers

To sort rows that share same value, must give `.sort_values()` a second column to use as a tie breaker. 

```{python}
penguins.sort_values(['island', 'bill_length_mm'])
```

Can provide as many columns to tie break/sort by, but MUST be passed as a LIST with `[]`

`.sort_values()` uses each new column to break ties among rows that share identical values in all of the preceding columns 

Default behavior:
- numeric: smallest number at top
- string: alpha order from A-Z then a-z
- another data type: similar ascending pattern

### Descending Order

Use `ascending = False`


```{python}
penguins.sort_values('bill_length_mm', ascending = False)
```

For multiple columns

- Provide a list of booleans
- `Nan` appear at end... `help(na_position)` shows default value is `last`

```{python}
penguins.sort_values(
  ['island', 'bill_length_mm'], 
  ascending = [True, False]
  )
```

Hmmm... none of these `help()` call worked
```{python}
#| eval: false
help(na_position)
help(pd.DataFrame.na_position)
```

```{python}
penguins.sort_values(
  ['island', 'year', 'flipper_length_mm'],
  ascending = [False, True, False]
)
```


```{python}
help(pd.DataFrame.sort_values)
```

### Aesthetic Mapping in `plotnine()`


```{python}
import plotnine as p9
from plotnine import ggplot, aes, geom_point, geom_smooth, geom_line
from plotnine.data import mpg
```


```{python}
mpg
```


```{python}
ggplot.show(
  ggplot(
    data = mpg, 
    mapping = aes(
      x = 'displ',
      y = 'hwy'
      )
    ) +
    geom_point()
)
```


```{python}
ggplot.show(
  ggplot(
    data = mpg,
    mapping = aes(
      x = 'displ', 
      y = 'hwy',
      color = 'class'
      )
    ) +
    geom_point()
)
```

**NB:** To fix labels from being cut off:

`from matplotlib import rcParams`
`rcParams.update({"savefig.bbox": "tight"})`

## Aesthetics

### `size`


```{python}

ggplot.show(
  ggplot(
    data = mpg, 
    mapping = aes(
      x = 'displ',
      y = 'hwy',
      color = 'class'
      )
    ) +
  geom_point(
    mapping = aes(
      size = 'class'
    )
  )  
)
```

### ~`transparency`~ `alpha` 


```{python}
ggplot.show(
  ggplot(
    data = mpg, 
    mapping = aes(
      x = 'displ',
      y = 'hwy'
      )
    ) +
    geom_point(
      mapping = aes(
        alpha = 'class'
      )
    )
)
```

### `shape`


```{python}

ggplot.show(
  ggplot(
    data = mpg, 
    mapping = aes(
      x = 'displ',
      y = 'hwy',
      shape = 'class'
      )
    ) +
    geom_point()
)
```

### For color blind check: 

[Coblis](https://www.color-blindness.com/coblis-color-blindness-simulator)

### Local aesthetics


```{python}

ggplot.show(
  ggplot(
    data = mpg, 
    mapping = aes(
      x = 'displ',
      y = 'hwy'
      )
    ) +
    geom_point(
      mapping = aes(
        color = 'class'
      )
    ) +
    geom_smooth()
)
```

```{python}

ggplot.show(
  ggplot(
    data = mpg, 
    mapping = aes(
      x = 'displ',
      y = 'hwy'
      )
    ) +
    geom_point(
      mapping = aes(
        color = 'class'
      )
    ) +
    geom_smooth(
      mapping = aes(
        color = 'class'
      )
    )
)
```

### Setting vs Mapping Aesthetics


```{python}

ggplot.show(
  ggplot(
    data = mpg, 
    mapping = aes(
      x = 'displ',
      y = 'hwy'
      )
    ) +
    geom_point(
      color = 'blue'
    )
)
```

```{python}

ggplot.show(
  ggplot(
    data = mpg, 
    mapping = aes(
      x = 'displ',
      y = 'hwy'
      )
    ) +
    geom_point(
      color = 'blue',
      shape = 'x',
      alpha = 0.5
    )
)
```

```{python}

ggplot.show(
  ggplot(
    data = mpg, 
    mapping = aes(
      x = 'displ',
      y = 'hwy'
      )
    ) +
    geom_point(
      mapping = aes(
        color = 'class',
        shape = 'fl',
        alpha = 'displ'
      )
    )  
)
```

### Exercise 1


```{python}
#| eval: false

ggplot.show(
  ggplot(
    data = mpg, 
    mapping = aes(
      x = 'displ',
      y = 'hwy'
      )
    ) +
    geom_point(
      mapping = aes(
        # color = 'cty'
        # size = 'cty'
        shape = 'cty'
      )
    )
)
```


```{python}

ggplot.show(
  ggplot(
    data = mpg, 
    mapping = aes(
      x = 'displ',
      y = 'hwy',
      color = 'cty'
      )
    ) +
    geom_point() +
    p9.scale_color_gradient(
      low = 'red', 
      high = 'darkblue'
    )
)
```

### Exercise 2

```{python}

ggplot.show(
  ggplot(
    data = mpg,
    mapping = aes(
      x = 'displ',
      y = 'hwy',
      color = 'class',
      size = 'class',
      shape = 'class'
      )
    ) +
    geom_point()
)

```

### Exercise 3


```{python}
ggplot.show(
  ggplot(
    data = mpg,
    mapping = aes(
      x = 'displ',
      y = 'hwy'
      )
    ) +
    geom_point(
      mapping = aes(
        color = 'displ < 5'
      )
    )
)
```

### Exercise 4


```{python}

ggplot.show(
  ggplot(
    data = mpg, 
    mapping = aes(
      x = 'displ',
      y = 'hwy'
      )
    ) +
    geom_point(
      mapping = aes(
        color = 'class'
      )
    ) +
    geom_smooth(
      color = "red"
    )
)
```

### The `group` Aesthetic

See [https://plotnine.org/](https://plotnine.org/)
```{python}
#| eval: false

(
  ggplot(
    data = df, 
    mapping = aes(
      x = 'x', 
      y = 'y',
      color = 'ID'
      )
    ) +
    geom_line(
      mapping = aes(
        group = 'ID' # <-
      )
    )
)
```


```{python}
help(geom_line)

```

### Check Out Jeroen's Data Viz with Plotnine

[https://f0nzie.github.io/rmarkdown-python-plotnine]()